#include <iostream>
using namespace std;

/*
!构造函数和析构函数
*对象的**初始化和清理**也是两个非常重要的安全问题
    ?一个对象或者变量没有初始状态，对其使用后果是未知
    ?同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题
*c++利用了**构造函数**和**析构函数**解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。
?对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器也会提供。
!编译器提供的构造函数和析构函数是空实现。
  *构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。
  *析构函数：主要作用在于对象**销毁前**系统自动调用，执行一些清理工作。
todo构造函数语法：类名(){}
  ?1. 构造函数，没有返回值也不写void
  ?2. 函数名称与类名相同
  *3. 构造函数可以有参数，因此可以发生重载
  *4. 程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次
todo析构函数语法：~类名(){}
  *1. 析构函数，没有返回值也不写void
  ?2. 函数名称与类名相同,在名称前加上符号  ~
  ?3. 析构函数不可以有参数，因此不可以发生重载
  *4. 程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次
 */

/*
!构造函数的分类及调用
?两种分类方式：
  *按参数分为： 有参构造和无参构造
  *按类型分为： 普通构造和拷贝构造
?三种调用方式：
  *括号法
  *显示法
  *隐式转换法
 */

/*
!构造函数调用规则
?默认情况下，c++编译器至少给一个类添加3个函数
  *1．默认构造函数(无参，函数体为空)
  *2．默认析构函数(无参，函数体为空)
  *3．默认拷贝构造函数，对属性进行值拷贝
?构造函数调用规则如下：
  todo 如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造
  todo 如果用户定义拷贝构造函数，c++不会再提供其他构造函数
  todo 注意：如果都不定义，c++会提供默认构造和拷贝构造
  todo 也就是后面的构造函数优先级高于前面的构造函数，有了后面的，c++就不会再提供前面的
 */

// 对象的初始化和清理
class Person
{
public:
  // // 1、构造函数
  // Person()
  // {
  //   cout << "Person的构造函数调用" << endl;
  // }
  // // 2、析构函数
  // ~Person()
  // {
  //   cout << "Person的析构函数调用" << endl;
  // }
  // !无参（默认）构造函数
  Person()
  {
    cout << "无参构造函数!" << endl;
    mAge = 0;
  }
  // !有参构造函数
  Person(int a)
  {
    age = a;
    cout << "有参构造函数!" << endl;
    mAge = a;
  }
  // !拷贝构造函数
  Person(const Person &p)
  {
    age = p.age;
    cout << "拷贝构造函数!" << endl;
    mAge = p.mAge;
  }
  // !析构函数
  ~Person()
  {
    cout << "析构函数!" << endl;
  }

public:
  int age;
  int mAge;
};

// 构造和析构都是必须要有的实现，如果我们不提供，编译器会自动提供空实现的构造和析构
// 调用无参的构造函数
void test01()
{
  Person p; // 在栈上的数据，test01执行完毕后，p对象会自动释放，调用析构函数

  Person p1(18);
  // 如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作
  Person p2(p1);

  cout << "p2的年龄为： " << p2.age << endl;
}

// 调用有参的构造函数
void test02()
{

  // !2.1  括号法，常用
  // Person p2(10); // 有参构造函数调用
  // 注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明
  // Person p1; //无参构造函数调用
  // Person p3(p2); //拷贝构造函数调用

  // !2.2 显式法
  Person p1;              // 无参构造函数调用
  Person p2 = Person(10); // 有参构造函数调用
  Person p3 = Person(p2); // 拷贝构造函数调用
  // Person(10)单独写就是匿名对象  当前行结束之后，马上析构

  // !2.3 隐式转换法
  Person p4 = 10; // 相当于Person p4 = Person(10);
  Person p5 = p4; // 相当于Person p5 = Person(p4);

  // 注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明
  // Person(p4); == Person p4; 可能就重定义了
  // Person p5(p4);
}

/*
!拷贝构造函数调用时机
?C++中拷贝构造函数调用时机通常有三种情况
  * 使用一个已经创建完毕的对象来初始化一个新对象
  * 值传递的方式给函数参数传值
  * 以值方式返回局部对象
 */

// !1. 使用一个已经创建完毕的对象来初始化一个新对象
void test03()
{

  Person man(100);      // p对象已经创建完毕
  Person newman(man);   // 调用拷贝构造函数
  Person newman2 = man; // 拷贝构造

  // Person newman3;
  // newman3 = man; //不是调用拷贝构造函数，赋值操作
}

// !2. 值传递的方式给函数参数传值
// 相当于Person p1 = p;
// void doWork(Person p1) {}
void test04()
{
  Person p; // 无参构造函数
  // doWork(p);
}

// !3. 以值方式返回局部对象
Person doWork2()
{
  Person p1;
  cout << (int *)&p1 << endl;
  return p1;
}

void test05()
{
  Person p = doWork2();
  cout << (int *)&p << endl;
}

void test06()
{
  // 如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造
  Person p1;     // 此时如果用户自己没有提供默认构造，会出错
  Person p2(10); // 用户提供的有参
  Person p3(p2); // 此时如果用户没有提供拷贝构造，编译器会提供

  // 如果用户提供拷贝构造，编译器不会提供其他构造函数
  Person p4;     // 此时如果用户自己没有提供默认构造，会出错
  Person p5(10); // 此时如果用户自己没有提供有参，会出错
  Person p6(p5); // 用户自己提供拷贝构造
}

int main()
{

  test01();

  test02();

  test03();
  // test04();
  // test05();

  // test06();

  // Person p1; // 在栈上的数据，main执行完毕后，p1对象会自动释放，调用析构函数，所以最后是看不到析构函数的调用

  system("pause");

  return 0;
}